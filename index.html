<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æˆ‘çš„ä¸‰æ¶ˆæ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            user-select: none;
            -webkit-user-select: none;
            touch-action: pan-x pan-y; /* æ”¹ä¸ºå…è®¸å¿…è¦çš„æ»šåŠ¨ */
            overscroll-behavior: none;
            position: fixed;
            width: 100%;
            height: 100%;
            overflow: auto; /* å…è®¸é¡µé¢æ»šåŠ¨ï¼Œä½† grid å†…ä¸æ»š */
        }

        h1 {
            color: #fff;
            margin: 15px 0 10px 0;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .score-board {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            padding: 8px 25px;
            border-radius: 25px;
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(8, 40px);
            grid-template-rows: repeat(8, 40px);
            gap: 2px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            
            /* å…³é”®ï¼šåªç¦æ­¢ grid å†…çš„è§¦æ‘¸æ»šåŠ¨ */
            touch-action: none;
        }

        .grid div {
            width: 40px;
            height: 40px;
            cursor: pointer;
            background-repeat: no-repeat;
            background-position: center;
            background-size: 85%;
            border: 2px solid transparent;
            border-radius: 8px;
            transition: all 0.15s ease;
            background-color: rgba(255,255,255,0.1);
        }

        .grid div:active {
            transform: scale(0.92);
        }

        .selected {
            background-color: rgba(255, 255, 255, 0.4) !important;
            border: 2px solid #ffeb3b !important;
            box-shadow: 0 0 15px rgba(255, 235, 59, 0.8);
            animation: pulse 0.6s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* æ¶ˆé™¤åŠ¨ç”» */
        .matched {
            animation: pop 0.3s ease forwards;
        }

        @keyframes pop {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(0); opacity: 0; }
        }

        .candy-red    { background-image: url('images/1.png'); }
        .candy-yellow { background-image: url('images/2.png'); }
        .candy-orange { background-image: url('images/3.png'); }
        .candy-purple { background-image: url('images/4.png'); }
        .candy-green  { background-image: url('images/5.png'); }
        .candy-blue   { background-image: url('images/6.png'); }

        .instructions {
            margin-top: 20px;
            color: rgba(255,255,255,0.9);
            font-size: 13px;
            text-align: center;
            line-height: 1.6;
            padding: 0 20px;
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 360px) {
            .grid {
                grid-template-columns: repeat(8, 36px);
                grid-template-rows: repeat(8, 36px);
            }
            .grid div {
                width: 36px;
                height: 36px;
            }
        }
    </style>
</head>
<body>

    <h1>ğŸ¬ å¼€å¿ƒæ¶ˆæ¶ˆä¹</h1>
    <div class="score-board">
        å¾—åˆ†: <span id="score">0</span>
    </div>

    <div class="grid"></div>

    <div class="instructions">
        ğŸ® æ»‘åŠ¨ç³–æœè¿›è¡Œäº¤æ¢<br>
        ğŸ’¡ æˆ–ç‚¹å‡»ä¸¤ä¸ªç›¸é‚»ç³–æœäº¤æ¢
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const grid = document.querySelector('.grid');
            const scoreDisplay = document.getElementById('score');
            const width = 8;
            const squares = [];
            let score = 0;

            const candyColors = [
                'candy-red', 'candy-yellow', 'candy-orange',
                'candy-purple', 'candy-green', 'candy-blue'
            ];

            // 1. åˆå§‹åŒ–æ£‹ç›˜ï¼ˆé¿å…åˆå§‹å°±æœ‰ä¸‰æ¶ˆï¼‰
            function createBoard() {
                for (let i = 0; i < width * width; i++) {
                    const square = document.createElement('div');
                    square.setAttribute('id', i);
                    
                    // éšæœºç”Ÿæˆï¼Œä½†é¿å…åˆå§‹ä¸‰æ¶ˆ
                    let randomColor;
                    let attempts = 0;
                    do {
                        randomColor = candyColors[Math.floor(Math.random() * candyColors.length)];
                        attempts++;
                    } while (attempts < 10 && wouldCreateMatch(i, randomColor));
                    
                    square.classList.add(randomColor);
                    grid.appendChild(square);
                    squares.push(square);
                }
            }

            // æ£€æŸ¥æ”¾ç½®è¯¥é¢œè‰²æ˜¯å¦ä¼šç«‹å³å½¢æˆä¸‰æ¶ˆ
            function wouldCreateMatch(index, color) {
                const row = Math.floor(index / width);
                const col = index % width;
                
                // æ£€æŸ¥æ¨ªå‘
                if (col >= 2) {
                    if (squares[index - 1]?.classList.contains(color) &&
                        squares[index - 2]?.classList.contains(color)) {
                        return true;
                    }
                }
                
                // æ£€æŸ¥çºµå‘
                if (row >= 2) {
                    if (squares[index - width]?.classList.contains(color) &&
                        squares[index - width * 2]?.classList.contains(color)) {
                        return true;
                    }
                }
                
                return false;
            }

            createBoard();

            // === æ ¸å¿ƒäº¤äº’é€»è¾‘ ===
            let selectedSquareId = null;
            let touchStartId = null;
            let startX = 0, startY = 0;
            let isTouchDevice = false;

            squares.forEach((square, index) => {
                // è§¦æ‘¸å¼€å§‹
                square.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    isTouchDevice = true;
                    
                    const touch = e.touches[0];
                    startX = touch.clientX;
                    startY = touch.clientY;
                    touchStartId = index;
                    
                    square.style.opacity = '0.7';
                }, { passive: false });

                // è§¦æ‘¸ç§»åŠ¨ï¼ˆé˜»æ­¢æ»šåŠ¨ï¼‰
                square.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                }, { passive: false });

                // è§¦æ‘¸ç»“æŸ
                square.addEventListener('touchend', (e) => {
                    square.style.opacity = '1';
                    
                    const touch = e.changedTouches[0];
                    const endX = touch.clientX;
                    const endY = touch.clientY;
                    const diffX = endX - startX;
                    const diffY = endY - startY;
                    const threshold = 15; // é™ä½æ»‘åŠ¨é˜ˆå€¼ï¼Œæé«˜çµæ•åº¦

                    // åˆ¤æ–­æ˜¯æ»‘åŠ¨è¿˜æ˜¯ç‚¹å‡»
                    if (Math.abs(diffX) > threshold || Math.abs(diffY) > threshold) {
                        // æ»‘åŠ¨äº¤æ¢
                        handleSwipe(touchStartId, diffX, diffY);
                        clearSelection();
                    } else {
                        // ç‚¹å‡»é€‰æ‹©
                        handleTap(index);
                    }
                });

                // é¼ æ ‡ç‚¹å‡»ï¼ˆä»…åœ¨éè§¦æ‘¸è®¾å¤‡ä¸Šï¼‰
                square.addEventListener('click', (e) => {
                    if (!isTouchDevice) {
                        handleTap(index);
                    }
                });
            });

            // å¤„ç†æ»‘åŠ¨
            function handleSwipe(startId, diffX, diffY) {
                let targetId;
                const row = Math.floor(startId / width);
                const col = startId % width;

                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // æ¨ªå‘æ»‘åŠ¨
                    if (diffX > 0 && col < width - 1) {
                        targetId = startId + 1; // å³æ»‘
                    } else if (diffX < 0 && col > 0) {
                        targetId = startId - 1; // å·¦æ»‘
                    }
                } else {
                    // çºµå‘æ»‘åŠ¨
                    if (diffY > 0 && row < width - 1) {
                        targetId = startId + width; // ä¸‹æ»‘
                    } else if (diffY < 0 && row > 0) {
                        targetId = startId - width; // ä¸Šæ»‘
                    }
                }

                if (targetId !== undefined) {
                    attemptSwap(startId, targetId);
                }
            }

            // å¤„ç†ç‚¹å‡»
            function handleTap(index) {
                if (selectedSquareId === null) {
                    // ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼šé€‰ä¸­
                    selectedSquareId = index;
                    squares[index].classList.add('selected');
                } else if (selectedSquareId === index) {
                    // ç‚¹å‡»åŒä¸€ä¸ªï¼šå–æ¶ˆé€‰ä¸­
                    clearSelection();
                } else {
                    // ç‚¹å‡»å¦ä¸€ä¸ªï¼šå°è¯•äº¤æ¢
                    const isAdjacent = checkAdjacent(selectedSquareId, index);
                    if (isAdjacent) {
                        attemptSwap(selectedSquareId, index);
                    }
                    clearSelection();
                }
            }

            // æ£€æŸ¥æ˜¯å¦ç›¸é‚»
            function checkAdjacent(id1, id2) {
                const row1 = Math.floor(id1 / width);
                const col1 = id1 % width;
                const row2 = Math.floor(id2 / width);
                const col2 = id2 % width;

                // åŒè¡Œä¸”ç›¸é‚»åˆ—
                if (row1 === row2 && Math.abs(col1 - col2) === 1) return true;
                // åŒåˆ—ä¸”ç›¸é‚»è¡Œ
                if (col1 === col2 && Math.abs(row1 - row2) === 1) return true;
                
                return false;
            }

            // æ¸…é™¤é€‰ä¸­çŠ¶æ€
            function clearSelection() {
                if (selectedSquareId !== null) {
                    squares[selectedSquareId].classList.remove('selected');
                    selectedSquareId = null;
                }
            }

            // å°è¯•äº¤æ¢
            function attemptSwap(id1, id2) {
                const color1 = getColor(squares[id1]);
                const color2 = getColor(squares[id2]);

                if (!color1 || !color2) return;

                // äº¤æ¢
                setColor(squares[id1], color2);
                setColor(squares[id2], color1);

                // å»¶è¿Ÿæ£€æŸ¥ï¼Œè®©åŠ¨ç”»æ’­æ”¾
                setTimeout(() => {
                    const hasMatch = checkAllMatches();
                    
                    if (!hasMatch) {
                        // æ— æ•ˆäº¤æ¢ï¼Œæ¢å›æ¥
                        setTimeout(() => {
                            setColor(squares[id1], color1);
                            setColor(squares[id2], color2);
                        }, 200);
                    }
                }, 50);
            }

            // è·å–é¢œè‰²ç±»å
            function getColor(square) {
                return Array.from(square.classList).find(c => c.startsWith('candy-'));
            }

            // è®¾ç½®é¢œè‰²
            function setColor(square, color) {
                square.className = '';
                if (color) square.classList.add(color);
            }

            // æ£€æŸ¥æ‰€æœ‰åŒ¹é…
            function checkAllMatches() {
                const rowMatch = checkRowForThree();
                const colMatch = checkColumnForThree();
                return rowMatch || colMatch;
            }

            // æ£€æŸ¥æ¨ªå‘ä¸‰æ¶ˆ
            function checkRowForThree() {
                let matchFound = false;
                
                for (let i = 0; i < width * width; i++) {
                    const row = Math.floor(i / width);
                    const col = i % width;
                    
                    if (col > width - 3) continue; // é˜²æ­¢è¶Šç•Œ
                    
                    const color = getColor(squares[i]);
                    if (!color) continue;
                    
                    if (getColor(squares[i + 1]) === color && 
                        getColor(squares[i + 2]) === color) {
                        
                        // æ·»åŠ æ¶ˆé™¤åŠ¨ç”»
                        [i, i + 1, i + 2].forEach(index => {
                            squares[index].classList.add('matched');
                            setTimeout(() => {
                                squares[index].className = '';
                            }, 300);
                        });
                        
                        score += 3;
                        matchFound = true;
                    }
                }
                
                if (matchFound) scoreDisplay.textContent = score;
                return matchFound;
            }

            // æ£€æŸ¥çºµå‘ä¸‰æ¶ˆ
            function checkColumnForThree() {
                let matchFound = false;
                
                for (let i = 0; i < width * (width - 2); i++) {
                    const color = getColor(squares[i]);
                    if (!color) continue;
                    
                    if (getColor(squares[i + width]) === color && 
                        getColor(squares[i + width * 2]) === color) {
                        
                        [i, i + width, i + width * 2].forEach(index => {
                            squares[index].classList.add('matched');
                            setTimeout(() => {
                                squares[index].className = '';
                            }, 300);
                        });
                        
                        score += 3;
                        matchFound = true;
                    }
                }
                
                if (matchFound) scoreDisplay.textContent = score;
                return matchFound;
            }

            // ä¸‹è½é€»è¾‘
            function moveDown() {
                for (let i = width * width - 1; i >= 0; i--) {
                    if (i >= width && !getColor(squares[i]) && getColor(squares[i - width])) {
                        const color = getColor(squares[i - width]);
                        setColor(squares[i], color);
                        setColor(squares[i - width], '');
                    }
                }
                
                // å¡«å……é¡¶éƒ¨ç©ºç¼º
                for (let i = 0; i < width; i++) {
                    if (!getColor(squares[i])) {
                        const randomColor = candyColors[Math.floor(Math.random() * candyColors.length)];
                        setColor(squares[i], randomColor);
                    }
                }
            }

            // æ¸¸æˆä¸»å¾ªç¯
            setInterval(() => {
                moveDown();
                checkAllMatches();
            }, 100);
        });
    </script>
</body>
</html>
